<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>Hand SOS ‚Äî 3‚Äëmode dropdown + manual stop</title>
<style>
    /* RESET & BASE ‚Äî scrollable */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html, body {
        width: 100%;
        min-height: 100vh;
        background: #0b0b0b;
        font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        overflow-x: hidden;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 16px 12px;
    }

    .detection-card {
        width: 100%;
        max-width: 1000px;
        margin: 0 auto 20px auto;
        background: #1a1a1a;
        border-radius: 32px;
        padding: 20px 16px 24px 16px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.6);
        border: 1px solid #333;
    }

    /* header with controls */
    .header-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 16px;
        gap: 12px;
    }

    h2 {
        color: #eee;
        font-weight: 400;
        font-size: 1.5rem;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        margin: 0;
    }

    h2 span {
        background: #2e7d32;
        font-size: 0.9rem;
        padding: 4px 14px;
        border-radius: 40px;
        color: white;
        font-weight: 500;
    }

    .control-panel {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
    }

    /* three‚Äëmode dropdown (camera control) */
    .camera-mode-selector {
        background: #252525;
        padding: 5px 10px;
        border-radius: 40px;
        border: 1px solid #444;
        color: #ccc;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .camera-mode-selector select {
        background: #3a3a3a;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 30px;
        font-weight: 500;
        font-size: 0.9rem;
        outline: 1px solid #666;
        cursor: pointer;
    }
    .camera-mode-selector select option {
        background: #2a2a2a;
    }

    /* manual stop button ‚Äì always visible, stops alarm immediately */
    .manual-stop-btn {
        background: #b71c1c;
        border: none;
        color: white;
        font-weight: 700;
        padding: 8px 28px;
        border-radius: 40px;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 12px rgba(180, 0, 0, 0.6);
        cursor: pointer;
        border: 1px solid #ffaaaa;
        transition: background 0.1s ease;
    }
    .manual-stop-btn:active {
        background: #7a0f0f;
    }
    .manual-stop-btn:disabled {
        background: #555;
        box-shadow: none;
        border-color: #777;
        cursor: not-allowed;
        opacity: 0.6;
    }

    .media-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        background: black;
        border-radius: 28px;
        overflow: hidden;
        border: 2px solid #3a3a3a;
        box-shadow: 0 8px 16px rgba(0,0,0,0.8);
        margin-bottom: 20px;
    }

    video, canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        pointer-events: none;
    }

    /* emergency overlay */
    .emergency-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 0, 0, 0.92);
        backdrop-filter: blur(4px);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 25;
        font-size: clamp(1.8rem, 10vw, 4rem);
        font-weight: 800;
        text-align: center;
        line-height: 1.4;
        text-shadow: 2px 2px 12px black;
        border-radius: 28px;
        border: 4px solid #ffcccc;
        box-shadow: inset 0 0 40px #b71c1c;
        padding: 16px;
        opacity: 0;
        transition: opacity 0.15s ease;
        pointer-events: none;
    }

    .emergency-overlay.show {
        opacity: 1;
    }

    .emergency-overlay small {
        font-size: 0.5em;
        background: black;
        padding: 8px 20px;
        border-radius: 60px;
        margin-top: 20px;
        font-weight: 400;
        letter-spacing: 1px;
    }

    .step-guide {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 12px;
        margin: 24px 0 16px 0;
        justify-content: center;
    }

    .guide-card {
        background: #262626;
        border-radius: 60px;
        padding: 12px 24px;
        color: #ddd;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1 1 auto;
        border: 1px solid #404040;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }

    .guide-card .emoji {
        font-size: 1.8rem;
        filter: drop-shadow(0 2px 2px black);
    }

    .guide-card.highlight {
        background: #2e3b2e;
        border-color: #6fda6f;
        color: #d0ffd0;
    }

    .footer-note {
        color: #777;
        font-size: 0.85rem;
        text-align: center;
        margin-top: 10px;
        border-top: 1px solid #2a2a2a;
        padding-top: 16px;
    }

    #alarm {
        display: none;
    }
</style>
</head>
<body>

<div class="detection-card">
    <!-- header with dropdown (3 functions) + manual stop button -->
    <div class="header-row">
        <h2>
            ‚úã SOS Palm Detection
            <span></span>
        </h2>
        <div class="control-panel">
            <!-- 3‚Äëmode dropdown: LIVE / PAUSED / OFF (camera) -->
            <div class="camera-mode-selector">
                <span>üì∑ CAM</span>
                <select id="cameraModeSelect">
                    <option value="live" selected>üî¥ LIVE (detection on)</option>
                    <option value="pause">‚è∏Ô∏è PAUSED (freeze frame)</option>
                    <option value="off">‚ö´ OFF (camera off)</option>
                </select>
            </div>
            <!-- manual stop button ‚Äì stops alarm and exits emergency -->
            <button id="manualStopBtn" class="manual-stop-btn">‚èπÔ∏è STOP ALARM</button>
        </div>
    </div>

    <!-- media container -->
    <div class="media-wrapper" id="mediaWrapper">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="alertOverlay" class="emergency-overlay">
            üö® SOS EMERGENCY üö®<br>
            <span style="font-size:0.7em;">HELP NEEDED</span>
            <small>‚úåÔ∏è two fingers or STOP button</small>
        </div>
    </div>

    <!-- instruction panels -->
    <div class="step-guide">
        <div class="guide-card" id="guideOpen">
            <span class="emoji">üñêÔ∏è</span> hold open palm 3s
        </div>
        <div class="guide-card" id="guideStop">
            <span class="emoji">‚úåÔ∏è</span> two fingers (or STOP button)
        </div>
    </div>

    <div class="footer-note">
        ‚ö° 3‚Äëmode dropdown: LIVE (detection), PAUSED (image frozen), OFF (camera released).<br>
        STOP ALARM button always works.
    </div>
</div>

<!-- alarm audio (hidden) -->
<audio id="alarm" loop>
    <source src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg" type="audio/ogg">
</audio>

<!-- MediaPipe & Camera helpers -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
(function() {
    // ----- DOM elements -----
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const alertOverlay = document.getElementById('alertOverlay');
    const alarm = document.getElementById('alarm');
    const guideOpen = document.getElementById('guideOpen');
    const guideStop = document.getElementById('guideStop');
    const manualStopBtn = document.getElementById('manualStopBtn');
    const cameraModeSelect = document.getElementById('cameraModeSelect');

    // ----- state -----
    let emergency = false;               // SOS active?
    let openHandStart = null;             // timestamp for open hand detection
    let cameraActive = true;              // reflects if camera stream is ON (for OFF mode)
    let detectionActive = true;           // true when in LIVE mode (detection on), false for PAUSED
    let currentCamera = null;             // mediapipe camera instance
    let cameraStream = null;              // raw stream from getUserMedia
    let animationFrame = null;             // for fallback freeze frame
    let lastVideoFrame = null;            // stored image for pause mode

    // ----- resize canvas to match wrapper -----
    function resizeCanvasToDisplay() {
        const wrapper = document.querySelector('.media-wrapper');
        if (!wrapper) return;
        const rect = wrapper.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
    }

    const resizeObserver = new ResizeObserver(() => {
        resizeCanvasToDisplay();
    });
    const wrapper = document.querySelector('.media-wrapper');
    if (wrapper) resizeObserver.observe(wrapper);
    window.addEventListener('resize', () => {
        setTimeout(resizeCanvasToDisplay, 30);
    });
    setTimeout(resizeCanvasToDisplay, 100);

    // ----- camera handling with three modes -----
    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            cameraStream = stream;
            video.srcObject = stream;
            // after stream is set, start mediapipe camera
            startMediaPipeCamera();
        } catch (err) {
            alert('Camera access is needed for hand detection.');
        }
    }

    function startMediaPipeCamera() {
        if (currentCamera) {
            currentCamera.stop();
        }
        currentCamera = new Camera(video, {
            onFrame: async () => {
                if (!cameraActive) return;           // OFF mode: no frames processed
                if (!detectionActive) {
                    // PAUSED mode: we don't run detection, but we could store a frame? 
                    // We'll handle separately: just do nothing, but video is live ‚Äì we want to freeze.
                    // So in paused mode we ignore sending to hands, but we also need to keep a static image.
                    // The paused logic is inside the fallback drawer.
                    return;
                }
                // LIVE mode: send for detection
                await hands.send({ image: video });
            },
            width: 1280,
            height: 720
        });
        currentCamera.start();
    }

    // stop entire camera stream (release)
    function stopCameraStream() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
            video.srcObject = null;
        }
        if (currentCamera) {
            currentCamera.stop();
            currentCamera = null;
        }
    }

    // restart camera from OFF to LIVE/PAUSE
    async function restartCamera() {
        if (cameraStream) {
            // already have stream? might be off, so ensure stopped
            stopCameraStream();
        }
        await initCamera();
    }

    // mode change handler
    cameraModeSelect.addEventListener('change', async (e) => {
        const mode = e.target.value;
        if (mode === 'live') {
            // LIVE: camera active, detection on
            cameraActive = true;
            detectionActive = true;
            if (!cameraStream) {
                await restartCamera();
            } else {
                // if stream exists but was paused, just set flags; ensure camera running
                if (!currentCamera) startMediaPipeCamera();
                else detectionActive = true; // it's already sending frames? we need to ensure onFrame uses flag
            }
            // reset any freeze overlay
        } else if (mode === 'pause') {
            // PAUSED: camera live but detection off ‚Üí we will display a frozen frame (the last processed image)
            cameraActive = true;
            detectionActive = false;   // stop sending to hands
            // we need to capture current video frame to freeze
            if (video.readyState >= 2) {
                // draw current video onto canvas and keep it
                if (canvas.width && canvas.height) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    // store that frame in lastVideoFrame?
                    lastVideoFrame = new Image();
                    lastVideoFrame.src = canvas.toDataURL('image/jpeg'); // crude but works
                }
            }
            // ensure camera keeps running (for when we go back to live)
            if (!currentCamera && cameraStream) {
                startMediaPipeCamera();
            }
        } else if (mode === 'off') {
            // OFF: release camera, stop all tracks
            cameraActive = false;
            detectionActive = false;
            stopCameraStream();
            // clear canvas to black or show "camera off"
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 30px monospace';
            ctx.fillStyle = '#aaa';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.fillText('üì∑ CAMERA OFF', canvas.width/2-130, canvas.height/2);
            ctx.shadowBlur = 0;
        }
    });

    // manual stop button: deactivate emergency
    manualStopBtn.addEventListener('click', () => {
        if (emergency) {
            deactivateEmergency('manual stop button');
        } else {
            // even if no emergency, we can provide feedback (maybe disable alarm)
            console.log('no active emergency');
        }
    });

    // ----- MediaPipe setup -----
    const hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    // start camera automatically after page load
    initCamera();

    // ----- helpers: finger count, drawing -----
    function drawDottedLine(p1, p2) {
        ctx.save();
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = '#ffffffcc';
        ctx.lineWidth = 2.5;
        ctx.stroke();
        ctx.restore();
    }

    function countFingers(landmarks) {
        let tips = [4, 8, 12, 16, 20];
        let bases = [2, 6, 10, 14, 18];
        let count = 0;
        for (let i = 1; i < 5; i++) {
            if (landmarks[tips[i]].y < landmarks[bases[i]].y) {
                count++;
            }
        }
        // thumb heuristic (right hand bias, acceptable for demo)
        if (landmarks[4].x < landmarks[3].x) count++;
        return count;
    }

    function isOpenHand(fingers) {
        return fingers >= 4;
    }

    // ----- emergency control -----
    function activateEmergency(source = 'auto') {
        if (emergency) return;
        emergency = true;
        alertOverlay.classList.add('show');
        alarm.play().catch(e => console.log('audio play needs interaction', e));
        guideOpen.classList.remove('highlight');
        guideStop.classList.add('highlight');
        console.log(`üö® SOS ACTIVATED (${source})`);
    }

    function deactivateEmergency(source = 'auto') {
        if (!emergency) return;
        emergency = false;
        alertOverlay.classList.remove('show');
        alarm.pause();
        alarm.currentTime = 0;
        openHandStart = null;
        guideStop.classList.remove('highlight');
        guideOpen.classList.remove('highlight');
        console.log(`‚úÖ Emergency stopped (${source})`);
    }

    // ----- results handler (only called when detectionActive = true) -----
    function onResults(results) {
        // update canvas size
        if (canvas.width === 0 || canvas.height === 0) {
            resizeCanvasToDisplay();
        }

        // draw video frame
        if (results.image) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        }

        // if no hand, reset timer
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            if (!emergency) openHandStart = null;
            return;
        }

        const landmarks = results.multiHandLandmarks[0];
        const points = landmarks.map(p => ({
            x: p.x * canvas.width,
            y: p.y * canvas.height
        }));

        // draw landmarks + skeleton
        ctx.fillStyle = '#ff3333';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        });

        const connections = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],
            [13,17],[17,18],[18,19],[19,20],[0,17]
        ];
        ctx.strokeStyle = '#b0ffb0';
        ctx.lineWidth = 2.5;
        connections.forEach(conn => {
            drawDottedLine(points[conn[0]], points[conn[1]]);
        });

        const fingers = countFingers(landmarks);

        // detection logic (only if not emergency)
        if (!emergency) {
            if (isOpenHand(fingers)) {
                if (openHandStart === null) {
                    openHandStart = Date.now();
                } else if (Date.now() - openHandStart >= 3000) {
                    activateEmergency('auto');
                }
                guideOpen.classList.add('highlight');
                guideStop.classList.remove('highlight');
            } else {
                openHandStart = null;
                guideOpen.classList.remove('highlight');
            }
        } else {
            // emergency active: two fingers stops
            if (fingers === 2) {
                deactivateEmergency('auto (two fingers)');
            } else {
                guideStop.classList.add('highlight');
                guideOpen.classList.remove('highlight');
            }
        }

        // finger count overlay
        ctx.font = 'bold 24px monospace';
        ctx.fillStyle = 'yellow';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 10;
        ctx.fillText('üñêÔ∏è'+fingers, 30, 70);
        ctx.shadowBlur = 0;
    }

    // ----- fallback drawer for PAUSED mode (freeze frame) and OFF mode cleanup -----
    function drawLoop() {
        const mode = cameraModeSelect.value;
        if (mode === 'pause' && cameraActive && !detectionActive) {
            // paused mode: we want to show a static image (last video frame)
            // but video is still live, we need to keep the canvas static.
            if (lastVideoFrame && lastVideoFrame.complete) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(lastVideoFrame, 0, 0, canvas.width, canvas.height);
            } else if (video.readyState >= 2) {
                // capture fresh frame
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                // store it
                lastVideoFrame = new Image();
                lastVideoFrame.src = canvas.toDataURL('image/jpeg');
            }
            // add paused overlay text
            ctx.font = 'bold 36px monospace';
            ctx.fillStyle = '#cccccc';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.fillText('‚è∏Ô∏è PAUSED', canvas.width/2-100, canvas.height/2);
            ctx.shadowBlur = 0;
        }
        else if (mode === 'off') {
            // already drawn black in handler, but we can refresh
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 30px monospace';
            ctx.fillStyle = '#aaa';
            ctx.shadowBlur = 10;
            ctx.fillText('üì∑ CAMERA OFF', canvas.width/2-130, canvas.height/2);
            ctx.shadowBlur = 0;
        }
        requestAnimationFrame(drawLoop);
    }
    drawLoop();

    // unlock audio on first touch
    document.body.addEventListener('touchstart', function unlock() {
        alarm.load();
    }, { once: true });
    document.body.addEventListener('click', function unlock() {
        alarm.load();
    }, { once: true });

    window.addEventListener('orientationchange', () => {
        setTimeout(resizeCanvasToDisplay, 50);
    });

})();
</script>
</body>
</html>
