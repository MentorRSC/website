<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>Hand SOS Detection ‚Äî Scrollable & Responsive</title>
<style>
    /* RESET & BASE ‚Äî ensure scrollability on all devices */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html, body {
        width: 100%;
        min-height: 100vh;
        background: #0b0b0b;
        font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        overflow-x: hidden;
        overflow-y: auto;    /* make page scrollable */
        -webkit-overflow-scrolling: touch; /* smooth scroll on iOS */
    }

    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start; /* content starts at top, can scroll */
        padding: 16px 12px;
    }

    /* main card / container ‚Äî respects safe area */
    .detection-card {
        width: 100%;
        max-width: 1000px;
        margin: 0 auto 20px auto;
        background: #1a1a1a;
        border-radius: 32px;
        padding: 20px 16px 24px 16px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.6);
        border: 1px solid #333;
    }

    h2 {
        color: #eee;
        font-weight: 400;
        font-size: 1.5rem;
        letter-spacing: 1px;
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    h2 span {
        background: #2e7d32;
        font-size: 0.9rem;
        padding: 4px 14px;
        border-radius: 40px;
        color: white;
        font-weight: 500;
    }

    .info-row {
        color: #aaa;
        font-size: 0.95rem;
        margin-bottom: 18px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px 28px;
        background: #252525;
        padding: 12px 18px;
        border-radius: 40px;
    }

    .info-row .badge {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .info-row i { font-style: normal; color: #ffb74d; }

    /* video canvas container ‚Äî aspect ratio locked, fills width */
    .media-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;     /* consistent rectangle, no overflow */
        background: black;
        border-radius: 28px;
        overflow: hidden;
        border: 2px solid #3a3a3a;
        box-shadow: 0 8px 16px rgba(0,0,0,0.8);
        margin-bottom: 20px;
    }

    video, canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;          /* covers area without stretching */
        pointer-events: none;       /* camera feed not interactive */
    }

    /* emergency overlay ‚Äî now placed INSIDE the media wrapper, so it's always in view */
    .emergency-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 0, 0, 0.92);
        backdrop-filter: blur(4px);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 25;
        font-size: clamp(1.8rem, 10vw, 4rem);
        font-weight: 800;
        text-align: center;
        line-height: 1.4;
        text-shadow: 2px 2px 12px black;
        border-radius: 28px;        /* matches wrapper */
        border: 4px solid #ffcccc;
        box-shadow: inset 0 0 40px #b71c1c;
        padding: 16px;
        opacity: 0;
        transition: opacity 0.15s ease;
        pointer-events: none;       /* allow clicks to pass if needed (alert just visual) */
    }

    .emergency-overlay.show {
        opacity: 1;
        pointer-events: all;        /* not interactive but visible */
    }

    .emergency-overlay small {
        font-size: 0.5em;
        background: black;
        padding: 8px 20px;
        border-radius: 60px;
        margin-top: 20px;
        font-weight: 400;
        letter-spacing: 1px;
    }

    /* instruction panels ‚Äî scrollable friendly */
    .step-guide {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 12px;
        margin: 24px 0 16px 0;
        justify-content: center;
    }

    .guide-card {
        background: #262626;
        border-radius: 60px;
        padding: 12px 24px;
        color: #ddd;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1 1 auto;
        border: 1px solid #404040;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    }

    .guide-card .emoji {
        font-size: 1.8rem;
        filter: drop-shadow(0 2px 2px black);
    }

    .guide-card.highlight {
        background: #2e3b2e;
        border-color: #6fda6f;
        color: #d0ffd0;
    }

    .footer-note {
        color: #777;
        font-size: 0.85rem;
        text-align: center;
        margin-top: 10px;
        border-top: 1px solid #2a2a2a;
        padding-top: 16px;
    }

    /* hide audio element */
    #alarm {
        display: none;
    }

    /* no extra margins breaking scroll */
    #container {
        width: 100%;
    }
</style>
</head>
<body>

<div class="detection-card">
    
    <h2>
        ‚úã SOS Palm Detection 
        <span>open palm 3s ‚Üí SOS</span>
    </h2>

    <div class="info-row">
        <div class="badge"><i>üì±</i> scrollable & responsive</div>
        <div class="badge"><i>üñêÔ∏è</i> 4+ fingers = open palm</div>
        <div class="badge"><i>‚úåÔ∏è</i> 2 fingers stops alarm</div>
    </div>

    <!-- media container: video, canvas, and alert inside (fixed relative) -->
    <div class="media-wrapper" id="mediaWrapper">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <!-- alert now inside the same wrapper, always visible when active -->
        <div id="alertOverlay" class="emergency-overlay">
            üö® SOS EMERGENCY üö®<br>
            <span style="font-size:0.7em;">HELP NEEDED</span>
            <small>‚úåÔ∏è two fingers to stop</small>
        </div>
    </div>

    <!-- quick status & guide (visible below video, no scroll clipping) -->
    <div class="step-guide">
        <div class="guide-card" id="guideOpen">
            <span class="emoji">üñêÔ∏è</span> hold open palm 3s
        </div>
        <div class="guide-card" id="guideStop">
            <span class="emoji">‚úåÔ∏è</span> show 2 fingers to stop
        </div>
    </div>

    <div class="footer-note">
        ‚ö° Make sure your hand is clearly visible. Alarm loops until 2 fingers raised.
    </div>
</div>

<!-- alarm audio (hidden) -->
<audio id="alarm" loop>
    <source src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg" type="audio/ogg">
</audio>

<!-- MediaPipe & Camera helpers -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
(function() {
    // ----- DOM elements -----
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const alertOverlay = document.getElementById('alertOverlay');
    const alarm = document.getElementById('alarm');
    const guideOpen = document.getElementById('guideOpen');
    const guideStop = document.getElementById('guideStop');

    // ----- state -----
    let emergency = false;
    let openHandStart = null;          // timestamp when open hand first detected

    // ----- resize canvas to match parent aspect (fills container) -----
    function resizeCanvasToDisplay() {
        const wrapper = document.querySelector('.media-wrapper');
        if (!wrapper) return;
        const rect = wrapper.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
    }

    // initial + observer to handle orientation/resize
    const resizeObserver = new ResizeObserver(() => {
        resizeCanvasToDisplay();
    });
    const wrapper = document.querySelector('.media-wrapper');
    if (wrapper) resizeObserver.observe(wrapper);
    window.addEventListener('resize', () => {
        setTimeout(resizeCanvasToDisplay, 30);
    });

    // also call after camera start
    setTimeout(resizeCanvasToDisplay, 100);

    // ----- camera permission -----
    navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            video.srcObject = stream;
        })
        .catch(err => {
            alert('Camera access is needed for hand detection. Please grant permission.');
        });

    // ----- MediaPipe setup -----
    const hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(video, {
        onFrame: async () => {
            await hands.send({ image: video });
        },
        width: 1280,
        height: 720
    });
    camera.start();

    // ----- helpers: dotted line, finger count -----
    function drawDottedLine(p1, p2) {
        ctx.save();
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = '#ffffffcc';
        ctx.lineWidth = 2.5;
        ctx.stroke();
        ctx.restore();
    }

    function countFingers(landmarks) {
        // tips: 4 (thumb), 8, 12, 16, 20 ; bases: 2,6,10,14,18
        let tips = [4, 8, 12, 16, 20];
        let bases = [2, 6, 10, 14, 18];
        let count = 0;

        // index to pinky
        for (let i = 1; i < 5; i++) {
            if (landmarks[tips[i]].y < landmarks[bases[i]].y) {
                count++;
            }
        }
        // thumb (assuming right hand; for left might need reverse, but simple cross)
        if (landmarks[4].x < landmarks[3].x) count++;   // works for right hand. acceptable for demo.

        return count;
    }

    function isOpenHand(fingers) {
        return fingers >= 4;
    }

    // ----- emergency activation / deactivation (UI & sound)-----
    function activateEmergency() {
        if (emergency) return;
        emergency = true;
        alertOverlay.classList.add('show');
        alarm.play().catch(e => console.log('audio play blocked until user interaction', e));
        // visual guide highlight
        guideOpen.classList.remove('highlight');
        guideStop.classList.add('highlight');
        console.log('üö® SOS ACTIVATED');
    }

    function deactivateEmergency() {
        if (!emergency) return;
        emergency = false;
        alertOverlay.classList.remove('show');
        alarm.pause();
        alarm.currentTime = 0;
        openHandStart = null;          // reset timer
        guideStop.classList.remove('highlight');
        guideOpen.classList.remove('highlight');
        console.log('‚úÖ Emergency stopped');
    }

    // ----- results handler -----
    function onResults(results) {
        // update canvas size if needed (ensuring correct drawing)
        if (canvas.width === 0 || canvas.height === 0) {
            resizeCanvasToDisplay();
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // draw video frame
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        }

        // if no hand, reset openHandStart and skip
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            if (!emergency) openHandStart = null;   // no hand, reset timer
            // still show any existing alert state unchanged
            return;
        }

        const landmarks = results.multiHandLandmarks[0]; // only one hand

        // convert to canvas coordinates
        const points = landmarks.map(p => ({
            x: p.x * canvas.width,
            y: p.y * canvas.height
        }));

        // draw landmarks
        ctx.fillStyle = '#ff3333';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        });

        // draw skeleton (dotted)
        const connections = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [5,9],[9,10],[10,11],[11,12],
            [9,13],[13,14],[14,15],[15,16],
            [13,17],[17,18],[18,19],[19,20],
            [0,17]
        ];

        ctx.strokeStyle = '#b0ffb0';
        ctx.lineWidth = 2.5;
        connections.forEach(conn => {
            drawDottedLine(points[conn[0]], points[conn[1]]);
        });

        // count fingers
        const fingers = countFingers(landmarks);

        // logic
        if (!emergency) {
            if (isOpenHand(fingers)) {
                if (openHandStart === null) {
                    openHandStart = Date.now();
                } else if (Date.now() - openHandStart >= 3000) {
                    activateEmergency();
                }
                // visual hint: highlight open guide
                guideOpen.classList.add('highlight');
                guideStop.classList.remove('highlight');
            } else {
                openHandStart = null;
                guideOpen.classList.remove('highlight');
            }
        } else {
            // emergency mode: check for two fingers to stop
            if (fingers === 2) {
                deactivateEmergency();
            } else {
                // keep highlight on stop guide
                guideStop.classList.add('highlight');
                guideOpen.classList.remove('highlight');
            }
        }

        // optional: show finger count on canvas? not needed but small debug
        ctx.font = 'bold 24px monospace';
        ctx.fillStyle = 'yellow';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 10;
        ctx.fillText('üñêÔ∏è'+fingers, 30, 70);
        ctx.shadowBlur = 0;
    }

    // extra: ensure alert overlay click doesn't block (but user might tap to allow audio)
    // Chrome often needs user interaction to play audio. If alarm doesn't play,
    // we can attempt to play on first hand detection with user gesture.
    // but since alarm is inside 'activateEmergency', we catch errors silently.
    // improve: preload audio context little?
    document.body.addEventListener('touchstart', function initAudio() {
        // just to unlock audio on mobile (any user interaction)
        alarm.load(); 
        console.log('audio context unlocked');
    }, { once: true });

    // Also on first hand result we could trigger a silent play?
    // but not needed ‚Äî user will tap somewhere.

    // ensure canvas gets resize on orientation change
    window.addEventListener('orientationchange', () => {
        setTimeout(resizeCanvasToDisplay, 50);
    });

})();
</script>

<!-- small note: due to mobile auto-play policies, user may need to tap once for alarm -->
</body>
</html>
