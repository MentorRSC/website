<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAND POP ¬∑ restart with peace sign (after game over)</title>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: #0c0f16;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            padding: 8px;
        }
        /* game container: width exactly 92% */
        .game-container {
            position: relative;
            width: 92vw;                    /* exactly 92% of viewport width */
            height: 96vh;
            border-radius: 32px;
            overflow: hidden;
            box-shadow: 0 20px 45px rgba(0,0,0,0.9);
            border: 2px solid #ffaa3366;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #1a1f2b;
            cursor: none;
        }
        /* dashboard inside container */
        #dashboard {
            position: absolute;
            top: 16px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            z-index: 20;
            flex-wrap: wrap;
            padding: 0 10px;
        }
        .panel {
            background: rgba(8, 12, 24, 0.8);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 180, 70, 0.4);
            border-radius: 40px;
            padding: 8px 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-weight: 600;
            font-size: 1.4rem;
        }
        .panel span {
            color: #ffb347;
            font-weight: 800;
            margin-left: 4px;
            min-width: 40px;
            text-align: center;
        }
        .time-bar-bg {
            width: 90px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            overflow: hidden;
            margin-left: 5px;
            border: 1px solid rgba(255,200,100,0.3);
        }
        .time-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6ef0a0, #ffcd7e);
            border-radius: 20px;
            transition: width 0.1s linear;
        }
        .gesture-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            color: #eee;
            padding: 10px 22px;
            border-radius: 40px;
            font-size: 1rem;
            border: 1px solid #ffaa3380;
            z-index: 30;
            pointer-events: none;
            font-weight: 500;
        }
        .pause-indicator {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(200, 50, 50, 0.95);
            color: white;
            padding: 6px 22px;
            border-radius: 40px;
            font-size: 1.3rem;
            font-weight: bold;
            backdrop-filter: blur(4px);
            border: 1px solid #ff8a8a;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
        }
        #gameover {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            visibility: hidden;
            border-radius: 32px;
        }
        .gameover-card {
            background: #1a1f2e;
            padding: 40px 50px;
            border-radius: 50px;
            border: 2px solid #ffaa33;
            text-align: center;
            box-shadow: 0 20px 40px black;
        }
        .gameover-card h1 {
            font-size: 3rem;
            color: #ffc164;
            margin-bottom: 15px;
        }
        .gameover-card p {
            font-size: 2rem;
            color: white;
        }
        #restartBtn {
            background: #ffaa33;
            border: none;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            color: #0b0e14;
            cursor: pointer;
            margin-top: 25px;
            transition: 0.2s;
        }
        #restartBtn:hover {
            background: #ffbf5e;
            transform: scale(1.03);
        }
        video { display: none; }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="canvas"></canvas>

    <!-- Dashboard inside container -->
    <div id="dashboard">
        <div class="panel">
            ‚è≥<span id="timerDisplay">30</span>s
            <div class="time-bar-bg"><div id="timeFill" class="time-fill" style="width:100%"></div></div>
        </div>
        <div class="panel">
            ‚ù§Ô∏è <span id="livesDisplay">3</span>
        </div>
        <div class="panel">
            üçä<span id="scoreDisplay">0</span>
        </div>
    </div>

    <!-- Pause indicator (hand lost) -->
    <div id="pauseIndicator" class="pause-indicator">‚è∏Ô∏è PAUSED ¬∑ no hand</div>

    <!-- Gesture hint: only peace sign for restart after game over -->
    <div class="gesture-hint">
        ‚úåÔ∏è after GAME OVER ¬∑ show peace sign (2 fingers) to restart
    </div>

    <!-- Game over overlay -->
    <div id="gameover">
        <div class="gameover-card">
            <h1>GAME OVER</h1>
            <p>üçä <span id="finalScore">0</span></p>
            <p>‚úåÔ∏è show peace sign to restart</p>
            <button id="restartBtn">‚Üª PLAY AGAIN</button>
        </div>
    </div>

    <video id="video" autoplay playsinline></video>
</div>

<script>
(function() {
    // ----- DOM elements inside container -----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');

    const timerSpan = document.getElementById('timerDisplay');
    const livesSpan = document.getElementById('livesDisplay');
    const scoreSpan = document.getElementById('scoreDisplay');
    const finalScoreSpan = document.getElementById('finalScore');
    const timeFill = document.getElementById('timeFill');
    const gameoverDiv = document.getElementById('gameover');
    const restartBtn = document.getElementById('restartBtn');
    const pauseIndicator = document.getElementById('pauseIndicator');

    // ----- Game constants -----
    const INIT_TIME = 30;
    const INIT_LIVES = 3;
    const TIME_PER_POP = 2;
    const BALL_RADIUS = 30;

    // ----- Game state -----
    let score = 0;
    let lives = INIT_LIVES;
    let timeLeft = INIT_TIME;
    let gameActive = true;

    // Hand tracking flags
    let handDetected = false;
    let fingerPos = { x: -100, y: -100, valid: false };

    // For peace gesture detection (only after game over)
    // No cooldown needed, but we add a small one to avoid spamming
    let lastPeaceTime = 0;
    const PEACE_COOLDOWN = 1200; // ms

    // Ball object
    let ball = {
        x: 300, y: 200, r: BALL_RADIUS,
        vx: 0.2, vy: 0.15,
    };

    // ----- resize canvas to container size (92vw) -----
    function resizeCanvas() {
        const container = canvas.parentElement;
        const w = container.clientWidth;
        const h = container.clientHeight;
        canvas.width = w;
        canvas.height = h;

        // reposition ball if outside
        const margin = ball.r + 15;
        if (ball.x < margin) ball.x = margin;
        if (ball.x > canvas.width - margin) ball.x = canvas.width - margin;
        if (ball.y < margin) ball.y = margin;
        if (ball.y > canvas.height - margin) ball.y = canvas.height - margin;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ----- spawn ball with random direction inside container -----
    function spawnBall() {
        const margin = ball.r + 25;
        ball.x = Math.random() * (canvas.width - 2 * margin) + margin;
        ball.y = Math.random() * (canvas.height - 2 * margin) + margin;
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.18 + Math.random() * 0.3;
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;
    }

    // ----- restart game -----
    function restartGame() {
        gameActive = true;
        gameoverDiv.style.visibility = 'hidden';
        score = 0;
        lives = INIT_LIVES;
        timeLeft = INIT_TIME;
        scoreSpan.innerText = score;
        livesSpan.innerText = lives;
        timerSpan.innerText = timeLeft;
        updateTimeBar();
        spawnBall();
        handDetected = false;
        fingerPos.valid = false;
        pauseIndicator.style.opacity = '0';
    }

    // ----- game over trigger -----
    function gameOver() {
        if (!gameActive) return;
        gameActive = false;
        finalScoreSpan.innerText = score;
        gameoverDiv.style.visibility = 'visible';
        pauseIndicator.style.opacity = '0';
    }

    // update time bar
    function updateTimeBar() {
        let percent = Math.max(0, (timeLeft / INIT_TIME) * 100);
        timeFill.style.width = percent + '%';
    }

    // ----- PEACE SIGN DETECTION (exactly 2 fingers: index & middle extended, others down) -----
    function isPeaceSign(landmarks) {
        // landmark indices: thumb:4, index:8, middle:12, ring:16, pinky:20
        // reference joints: index:6 (dip), middle:10, ring:14, pinky:18, thumb:3 (ip)
        
        // Check index (tip higher than dip)
        const indexTip = landmarks[8];
        const indexDip = landmarks[6];
        const indexUp = indexTip.y < indexDip.y - 0.02;
        
        // Check middle (tip higher than dip)
        const middleTip = landmarks[12];
        const middleDip = landmarks[10];
        const middleUp = middleTip.y < middleDip.y - 0.02;
        
        // Ring should be down (tip lower than dip)
        const ringTip = landmarks[16];
        const ringDip = landmarks[14];
        const ringDown = ringTip.y > ringDip.y + 0.01;  // lower = bigger y
        
        // Pinky should be down
        const pinkyTip = landmarks[20];
        const pinkyDip = landmarks[18];
        const pinkyDown = pinkyTip.y > pinkyDip.y + 0.01;
        
        // Thumb should be down (not extended) ‚Äì use thumb IP vs tip
        const thumbTip = landmarks[4];
        const thumbIp = landmarks[3];  // joint below tip
        // Thumb is considered down if tip is close to hand (simple: tip y > ip y or tip x not too far)
        // For simplicity, we require thumb not to be up: tip y > ip y - 0.02? 
        // Usually thumb is "down" when it's not sticking out. We'll treat as down if tip y > ip y - 0.01 (rough)
        const thumbDown = thumbTip.y > thumbIp.y - 0.02; 
        
        // Peace sign = index up, middle up, ring down, pinky down, thumb down
        return indexUp && middleUp && ringDown && pinkyDown && thumbDown;
    }

    // ----- MediaPipe hands -----
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults((results) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw mirrored camera
        if (results.image) {
            ctx.save();
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        } else {
            ctx.fillStyle = '#1e2433';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Process hand landmarks
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // ----- PEACE GESTURE CHECK (only when game is NOT active) -----
            if (!gameActive) {
                const now = Date.now();
                if (isPeaceSign(landmarks) && (now - lastPeaceTime > PEACE_COOLDOWN)) {
                    lastPeaceTime = now;
                    restartGame();  // peace sign restarts the game
                }
            }

            // fingertip (index) for pointer (always draw for visual feedback)
            const indexTip = landmarks[8];
            const rawX = indexTip.x * canvas.width;
            const rawY = indexTip.y * canvas.height;
            const mirroredX = canvas.width - rawX;

            fingerPos.x = mirroredX;
            fingerPos.y = rawY;
            fingerPos.valid = true;

            // Draw fingertip pointer (bright)
            ctx.beginPath();
            ctx.arc(fingerPos.x, fingerPos.y, 18, 0, 2*Math.PI);
            ctx.fillStyle = '#44ffb0';
            ctx.shadowColor = '#0f0';
            ctx.shadowBlur = 40;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.stroke();

            // small central dot
            ctx.beginPath();
            ctx.arc(fingerPos.x, fingerPos.y, 6, 0, 2*Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        } else {
            handDetected = false;
            fingerPos.valid = false;
        }

        // Draw ball
        ctx.shadowColor = '#ffaa33';
        ctx.shadowBlur = 30;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, 2*Math.PI);
        ctx.fillStyle = '#ff8c00';
        ctx.fill();
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(ball.x-5, ball.y-5, ball.r-8, 0, 2*Math.PI);
        ctx.fillStyle = '#ffb86b';
        ctx.fill();
        ctx.shadowBlur = 0;
        // highlight
        ctx.beginPath();
        ctx.arc(ball.x-10, ball.y-10, 8, 0, 2*Math.PI);
        ctx.fillStyle = '#fff3d1';
        ctx.globalAlpha = 0.4;
        ctx.fill();
        ctx.globalAlpha = 1;
    });

    // Camera (always sending frames for gesture detection)
    const camera = new Camera(video, {
        onFrame: async () => {
            await hands.send({ image: video }); // always process
        },
        width: 1280,
        height: 720,
        facingMode: 'user'
    });
    camera.start().catch(e => console.warn('camera error', e));

    // ----- game loop (timer, collisions) -----
    let lastTimestamp = 0;

    function gameLoop(now) {
        if (!lastTimestamp) {
            lastTimestamp = now;
            requestAnimationFrame(gameLoop);
            return;
        }

        const deltaTime = now - lastTimestamp;
        lastTimestamp = now;

        if (gameActive) {
            // Timer decreases only if hand detected
            if (handDetected) {
                timeLeft -= deltaTime / 1000;
                pauseIndicator.style.opacity = '0';
            } else {
                pauseIndicator.style.opacity = '1';
            }

            // Time out?
            if (timeLeft <= 0) {
                timeLeft = 0;
                lives--;
                livesSpan.innerText = lives;
                if (lives <= 0) {
                    gameOver();
                } else {
                    timeLeft = INIT_TIME * 0.7; // partial refill
                }
            }

            // update displays
            timerSpan.innerText = timeLeft.toFixed(1);
            updateTimeBar();

            // Move ball
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Bounce off walls
            if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.8; }
            if (ball.x > canvas.width - ball.r) { ball.x = canvas.width - ball.r; ball.vx *= -0.8; }
            if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -0.8; }
            if (ball.y > canvas.height - ball.r) { ball.y = canvas.height - ball.r; ball.vy *= -0.8; }

            // Pop detection (if finger valid)
            if (fingerPos.valid) {
                const dx = fingerPos.x - ball.x;
                const dy = fingerPos.y - ball.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < ball.r + 20) {
                    score++;
                    scoreSpan.innerText = score;
                    timeLeft = Math.min(timeLeft + TIME_PER_POP, 45);
                    timerSpan.innerText = timeLeft.toFixed(1);
                    updateTimeBar();
                    spawnBall();

                    // visual flash
                    ctx.save();
                    ctx.fillStyle = 'rgba(255,255,200,0.4)';
                    ctx.fillRect(0,0,canvas.width,canvas.height);
                    ctx.restore();
                }
            }

            if (lives <= 0) gameOver();
        }

        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // restart button click (manual fallback)
    restartBtn.addEventListener('click', restartGame);

    // initial spawn
    spawnBall();
})();
</script>
</body>
</html>
