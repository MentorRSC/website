<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GESTURE STATES ¬∑ temporal confidence ¬∑ real hands ok</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background: #0a0d14;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            padding: 6px;
        }
        .game-container {
            position: relative;
            width: 92vw;
            height: 96vh;
            border-radius: 32px;
            overflow: hidden;
            box-shadow: 0 20px 45px rgba(0,0,0,0.9);
            border: 2px solid #ffaa3366;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #141a26;
            cursor: none;
        }
        #dashboard {
            position: absolute;
            top: 16px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            z-index: 20;
            flex-wrap: wrap;
            padding: 0 10px;
        }
        .panel {
            background: rgba(8, 12, 24, 0.8);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 180, 70, 0.4);
            border-radius: 40px;
            padding: 8px 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-weight: 600;
            font-size: 1.4rem;
        }
        .panel span {
            color: #ffb347;
            font-weight: 800;
            margin-left: 4px;
            min-width: 40px;
            text-align: center;
        }
        .time-bar-bg {
            width: 90px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            overflow: hidden;
            margin-left: 5px;
            border: 1px solid rgba(255,200,100,0.3);
        }
        .time-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6ef0a0, #ffcd7e);
            border-radius: 20px;
            transition: width 0.1s linear;
        }
        .control-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 60;
            pointer-events: auto;
        }
        .ctrl-btn {
            background: #1e2a3a;
            border: 2px solid #ffb347;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 10px 18px;
            border-radius: 50px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px black;
            transition: 0.2s;
            line-height: 1;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ctrl-btn.active {
            background: #2f6b3e;
            border-color: #a0ff9e;
            color: #e8ffe8;
        }
        #musicBtn {
            background: #2a2a4a;
            border-color: #aa88ff;
        }
        #musicBtn.playing {
            background: #4a3a8a;
            border-color: #cc99ff;
        }
        .pause-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(200, 50, 50, 0.95);
            color: white;
            padding: 6px 22px;
            border-radius: 40px;
            font-size: 1.3rem;
            font-weight: bold;
            backdrop-filter: blur(4px);
            border: 1px solid #ff8a8a;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
        }
        .gesture-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
            color: #eee;
            padding: 10px 22px;
            border-radius: 40px;
            font-size: 1rem;
            border: 1px solid #ffaa3380;
            z-index: 30;
            pointer-events: none;
            font-weight: 500;
            transition: opacity 0.8s;
        }
        .gesture-hint.fade {
            opacity: 0;
        }
        #gameover {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            visibility: hidden;
            border-radius: 32px;
        }
        .gameover-card {
            background: #1a1f2e;
            padding: 40px 50px;
            border-radius: 50px;
            border: 2px solid #ffaa33;
            text-align: center;
            box-shadow: 0 20px 40px black;
        }
        .gameover-card h1 {
            font-size: 3rem;
            color: #ffc164;
            margin-bottom: 15px;
        }
        .gameover-card p {
            font-size: 2rem;
            color: white;
        }
        #restartBtn {
            background: #ffaa33;
            border: none;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            color: #0b0e14;
            cursor: pointer;
            margin-top: 25px;
            transition: 0.2s;
        }
        #restartBtn:hover {
            background: #ffbf5e;
            transform: scale(1.03);
        }
        video { display: none; }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="canvas"></canvas>

    <div class="control-bar">
        <div id="toggleGameBtn" class="ctrl-btn active">‚èπÔ∏è STOP</div>
        <div id="musicBtn" class="ctrl-btn playing">üéµ ON</div>
    </div>

    <div id="dashboard">
        <div class="panel">
            ‚è≥<span id="timerDisplay">30</span>s
            <div class="time-bar-bg"><div id="timeFill" class="time-fill" style="width:100%"></div></div>
        </div>
        <div class="panel">
            ‚ù§Ô∏è <span id="livesDisplay">3</span>
        </div>
        <div class="panel">
            üçä<span id="scoreDisplay">0</span>
        </div>
    </div>

    <div id="pauseIndicator" class="pause-indicator">‚è∏Ô∏è NO HAND ¬∑ waiting</div>
    <div class="gesture-hint" id="gestureHint">
        ‚úåÔ∏è peace = restart &nbsp; ‚úä fist = STOP &nbsp; (hold 0.3s)
    </div>

    <div id="gameover">
        <div class="gameover-card">
            <h1>GAME OVER</h1>
            <p>üçä <span id="finalScore">0</span></p>
            <p>‚úåÔ∏è show peace sign to restart</p>
            <button id="restartBtn">‚Üª PLAY AGAIN</button>
        </div>
    </div>

    <video id="video" autoplay playsinline></video>
</div>

<script>
(function() {
    // ----- DOM -----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');
    const timerSpan = document.getElementById('timerDisplay');
    const livesSpan = document.getElementById('livesDisplay');
    const scoreSpan = document.getElementById('scoreDisplay');
    const finalScoreSpan = document.getElementById('finalScore');
    const timeFill = document.getElementById('timeFill');
    const gameoverDiv = document.getElementById('gameover');
    const restartBtn = document.getElementById('restartBtn');
    const pauseIndicator = document.getElementById('pauseIndicator');
    const toggleBtn = document.getElementById('toggleGameBtn');
    const musicBtn = document.getElementById('musicBtn');
    const hintEl = document.getElementById('gestureHint');

    setTimeout(() => hintEl.classList.add('fade'), 4000);

    // ----- AUDIO (same as before, but keep it) -----
    let audioCtx = null;
    let musicGain = null;
    let musicOscillator = null;
    let isMusicPlaying = false;
    let musicEnabled = true;
    let soundEnabled = true;

    function initAudio() {
        if (audioCtx) return;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            musicGain = audioCtx.createGain();
            musicGain.gain.value = 0;
            musicGain.connect(audioCtx.destination);
        } catch (e) { console.warn('Audio not supported'); }
    }

    function startMusic() {
        if (!audioCtx) initAudio();
        if (!audioCtx || isMusicPlaying) return;
        if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => playMusicTone());
        } else {
            playMusicTone();
        }
    }

    function playMusicTone() {
        if (musicOscillator) try { musicOscillator.stop(); } catch(e) {}
        musicOscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.12;
        musicOscillator.type = 'sine';
        musicOscillator.frequency.value = 175;
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 4;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 20;
        lfo.connect(lfoGain);
        lfoGain.connect(musicOscillator.frequency);
        lfo.start();
        musicOscillator.connect(gainNode);
        gainNode.connect(musicGain);
        musicGain.gain.setValueAtTime(0.12, audioCtx.currentTime);
        musicOscillator.start();
        isMusicPlaying = true;
        musicOscillator.lfo = lfo;
    }

    function stopMusic() {
        if (musicOscillator) {
            try { musicOscillator.stop(); if (musicOscillator.lfo) musicOscillator.lfo.stop(); } catch(e) {}
            musicOscillator = null;
        }
        isMusicPlaying = false;
    }

    function setMusicEnabled(enable) {
        musicEnabled = enable;
        if (enable) { if (audioCtx?.state === 'suspended') audioCtx.resume(); startMusic(); musicBtn.innerHTML = 'üéµ ON'; musicBtn.classList.add('playing'); } 
        else { stopMusic(); musicBtn.innerHTML = 'üéµ OFF'; musicBtn.classList.remove('playing'); }
    }

    function playPopSound() {
        if (!soundEnabled || !audioCtx || audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.type = 'sine'; osc.frequency.value = 620; gain.gain.value = 0.1;
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.15);
    }

    function playRedHitSound() {
        if (!soundEnabled || !audioCtx || audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.type = 'sawtooth'; osc.frequency.value = 220; gain.gain.value = 0.25;
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.25);
    }

    function playFistStopSound() {
        if (!soundEnabled || !audioCtx || audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.type = 'triangle'; osc.frequency.value = 140; gain.gain.value = 0.3;
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
        osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.4);
    }

    function initAudioOnUserGesture() {
        if (!audioCtx) initAudio();
        if (audioCtx?.state === 'suspended') audioCtx.resume().then(() => { if (musicEnabled && !isMusicPlaying) startMusic(); }).catch(() => {});
        else if (musicEnabled && !isMusicPlaying) startMusic();
    }
    document.body.addEventListener('click', initAudioOnUserGesture, { once: true });

    // ----- GAME CONSTANTS -----
    const INIT_TIME = 30;
    const INIT_LIVES = 3;
    const TIME_PER_POP = 2;
    const ORANGE_RADIUS = 30;
    const RED_RADIUS = 28;

    // ----- GAME STATE -----
    let score = 0;
    let lives = INIT_LIVES;
    let timeLeft = INIT_TIME;
    let gameActive = true;         
    let gameOverFlag = false;       
    let manualStop = false;         

    // Hand tracking
    let handDetected = false;
    let fingerPos = { x: -100, y: -100, valid: false };
    let smoothedX = -100, smoothedY = -100;

    // ----- ROBUST GESTURE STATE MACHINE (temporal, not per-frame fragile) -----
    const GESTURE_FRAMES_REQUIRED = 6;  // need ~6 consecutive detections (at ~30fps = 0.2s)
    let peaceCounter = 0;
    let fistCounter = 0;
    let lastProcessedPeace = 0;
    let lastProcessedFist = 0;
    const GESTURE_COOLDOWN = 1500; // ms between trigger actions

    // Ball objects
    let orange = { x: 300, y: 200, r: ORANGE_RADIUS, vx: 0.2, vy: 0.15 };
    let redBall = { active: true, x: 150, y: 400, r: RED_RADIUS, vx: -0.3, vy: 0.25 };

    // ----- HELPER FUNCTIONS -----
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        [orange, redBall].forEach(b => {
            const margin = b.r + 20;
            if (b.x < margin) b.x = margin;
            if (b.x > canvas.width - margin) b.x = canvas.width - margin;
            if (b.y < margin) b.y = margin;
            if (b.y > canvas.height - margin) b.y = canvas.height - margin;
        });
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function spawnOrange() {
        const margin = orange.r + 25;
        orange.x = Math.random() * (canvas.width - 2 * margin) + margin;
        orange.y = Math.random() * (canvas.height - 2 * margin) + margin;
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.18 + Math.random() * 0.3;
        orange.vx = Math.cos(angle) * speed;
        orange.vy = Math.sin(angle) * speed;
    }

    function spawnRed() {
        const margin = redBall.r + 25;
        redBall.x = Math.random() * (canvas.width - 2 * margin) + margin;
        redBall.y = Math.random() * (canvas.height - 2 * margin) + margin;
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.24 + Math.random() * 0.3;
        redBall.vx = Math.cos(angle) * speed;
        redBall.vy = Math.sin(angle) * speed;
        redBall.active = true;
    }

    function restartGame() {
        gameActive = true;
        gameOverFlag = false;
        manualStop = false;
        toggleBtn.innerHTML = '‚èπÔ∏è STOP';
        toggleBtn.classList.add('active');
        gameoverDiv.style.visibility = 'hidden';
        score = 0; lives = INIT_LIVES; timeLeft = INIT_TIME;
        scoreSpan.innerText = score; livesSpan.innerText = lives; timerSpan.innerText = timeLeft;
        updateTimeBar();
        spawnOrange(); spawnRed();
        handDetected = false; fingerPos.valid = false; pauseIndicator.style.opacity = '0';
        smoothedX = smoothedY = -100;
        peaceCounter = 0; fistCounter = 0; // reset gesture counters
    }

    function triggerGameOver(byFist = false) {
        if (gameOverFlag) return;
        gameActive = false; gameOverFlag = true; manualStop = false;
        toggleBtn.innerHTML = '‚ñ∂Ô∏è START'; toggleBtn.classList.remove('active');
        finalScoreSpan.innerText = score;
        gameoverDiv.style.visibility = 'visible';
        pauseIndicator.style.opacity = '0';
        if (byFist) playFistStopSound();
    }

    function manualGameStop() {
        if (!gameActive) return;
        gameActive = false; manualStop = true; gameOverFlag = false;
        toggleBtn.innerHTML = '‚ñ∂Ô∏è START'; toggleBtn.classList.remove('active');
        gameoverDiv.style.visibility = 'hidden';
        pauseIndicator.style.opacity = handDetected ? '0' : '1';
    }

    function manualGameStart() {
        if (gameOverFlag) restartGame();
        else { gameActive = true; manualStop = false; toggleBtn.innerHTML = '‚èπÔ∏è STOP'; toggleBtn.classList.add('active'); pauseIndicator.style.opacity = '0'; }
    }

    function loseLife() {
        if (!gameActive || gameOverFlag) return;
        lives--; livesSpan.innerText = lives;
        playRedHitSound();
        if (lives <= 0) triggerGameOver(false);
        else { spawnRed(); ctx.save(); ctx.fillStyle = 'rgba(255,80,80,0.3)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }
    }

    function updateTimeBar() {
        let percent = Math.max(0, (timeLeft / INIT_TIME) * 100);
        timeFill.style.width = percent + '%';
    }

    // ----- GESTURE DETECTION (tolerant, uses finger curl ratios instead of hard thresholds) -----
    function isPeaceLike(landmarks) {
        // Peace: index and middle extended, ring and pinky curled
        // Use relative positions: tip above pip for extended, below for curled (with margin)
        const indexTip = landmarks[8].y;
        const indexPip = landmarks[6].y;
        const middleTip = landmarks[12].y;
        const middlePip = landmarks[10].y;
        const ringTip = landmarks[16].y;
        const ringPip = landmarks[14].y;
        const pinkyTip = landmarks[20].y;
        const pinkyPip = landmarks[18].y;
        
        // Extended if tip is sufficiently above pip (negative in y up coordinate, but MediaPipe y increases downward)
        // So "extended" means tip.y < pip.y - margin
        const extendedIndex = indexTip < indexPip - 0.02;
        const extendedMiddle = middleTip < middlePip - 0.02;
        const curledRing = ringTip > ringPip + 0.015;
        const curledPinky = pinkyTip > pinkyPip + 0.015;
        
        return extendedIndex && extendedMiddle && curledRing && curledPinky;
    }

    function isFistLike(landmarks) {
        // Fist: all fingers curled (tip below pip)
        const fingers = [8, 12, 16, 20]; // tips
        const pips = [6, 10, 14, 18];
        let curledCount = 0;
        for (let i = 0; i < 4; i++) {
            if (landmarks[fingers[i]].y > landmarks[pips[i]].y + 0.015) curledCount++;
        }
        // Thumb also curled (tip below ip)
        const thumbTip = landmarks[4].y;
        const thumbIp = landmarks[3].y;
        const thumbCurled = thumbTip > thumbIp - 0.01;
        
        return curledCount >= 3 && thumbCurled; // at least 3 of 4 fingers curled + thumb
    }

    // ----- MediaPipe setup -----
    const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6, selfieMode: true });

    hands.onResults((results) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        else { ctx.fillStyle = '#141a26'; ctx.fillRect(0, 0, canvas.width, canvas.height); }

        if (results.multiHandLandmarks?.length) {
            handDetected = true;
            const lm = results.multiHandLandmarks[0];
            const now = Date.now();

            initAudioOnUserGesture(); // try init audio

            // ----- GESTURE STATE MACHINE (accumulate confidence) -----
            if (isPeaceLike(lm)) {
                peaceCounter = Math.min(peaceCounter + 1, GESTURE_FRAMES_REQUIRED);
            } else {
                peaceCounter = Math.max(peaceCounter - 1, 0);
            }

            if (isFistLike(lm)) {
                fistCounter = Math.min(fistCounter + 1, GESTURE_FRAMES_REQUIRED);
            } else {
                fistCounter = Math.max(fistCounter - 1, 0);
            }

            // Trigger peace only if game over and counter high enough
            if (gameOverFlag && peaceCounter >= GESTURE_FRAMES_REQUIRED && (now - lastProcessedPeace) > GESTURE_COOLDOWN) {
                lastProcessedPeace = now;
                restartGame();
            }

            // Trigger fist only if game active and counter high enough
            if (gameActive && !gameOverFlag && fistCounter >= GESTURE_FRAMES_REQUIRED && (now - lastProcessedFist) > GESTURE_COOLDOWN) {
                lastProcessedFist = now;
                triggerGameOver(true);
            }

            // fingertip smoothing (same as before)
            const idx = lm[8];
            let rawX = idx.x * canvas.width, rawY = idx.y * canvas.height;
            if (smoothedX < 0) { smoothedX = rawX; smoothedY = rawY; }
            else { const a = 0.35; smoothedX = smoothedX * a + rawX * (1 - a); smoothedY = smoothedY * a + rawY * (1 - a); }
            fingerPos.x = smoothedX; fingerPos.y = smoothedY; fingerPos.valid = true;

            // Draw fingertip
            ctx.beginPath(); ctx.arc(fingerPos.x, fingerPos.y, 18, 0, 2*Math.PI);
            ctx.fillStyle = '#55ffb0'; ctx.shadowColor = '#00cc88'; ctx.shadowBlur = 25; ctx.fill();
            ctx.shadowBlur = 0; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.stroke();
            ctx.beginPath(); ctx.arc(fingerPos.x, fingerPos.y, 6, 0, 2*Math.PI); ctx.fillStyle = '#ffffff'; ctx.fill();
        } else {
            handDetected = false; fingerPos.valid = false; smoothedX = smoothedY = -100;
            peaceCounter = 0; fistCounter = 0; // decay counters when hand lost
        }

        // Draw orange
        ctx.shadowColor = '#ffaa33'; ctx.shadowBlur = 25;
        ctx.beginPath(); ctx.arc(orange.x, orange.y, orange.r, 0, 2*Math.PI); ctx.fillStyle = '#ff8c00'; ctx.fill();
        ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.arc(orange.x-5, orange.y-5, orange.r-8, 0, 2*Math.PI); ctx.fillStyle = '#ffb86b'; ctx.fill();
        ctx.shadowBlur = 0;

        if (redBall.active) {
            ctx.shadowColor = '#ff3a3a'; ctx.shadowBlur = 30;
            ctx.beginPath(); ctx.arc(redBall.x, redBall.y, redBall.r, 0, 2*Math.PI); ctx.fillStyle = '#d83030'; ctx.fill();
            ctx.shadowBlur = 12;
            ctx.beginPath(); ctx.arc(redBall.x-5, redBall.y-5, redBall.r-8, 0, 2*Math.PI); ctx.fillStyle = '#ff7777'; ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    const camera = new Camera(video, { onFrame: async () => { await hands.send({ image: video }); }, width: 800, height: 600, facingMode: 'user' });
    camera.start().catch(e => console.warn);

    // ----- GAME LOOP (physics) -----
    let lastTimestamp = 0;
    function gameLoop(now) {
        if (!lastTimestamp) { lastTimestamp = now; requestAnimationFrame(gameLoop); return; }
        const delta = now - lastTimestamp; lastTimestamp = now;

        if (!handDetected && gameActive && !gameOverFlag && !manualStop) pauseIndicator.style.opacity = '1';
        else pauseIndicator.style.opacity = '0';

        if (gameActive && !gameOverFlag) {
            if (handDetected) timeLeft -= delta / 1000;
            if (timeLeft <= 0) { timeLeft = INIT_TIME * 0.8; lives--; livesSpan.innerText = lives; if (lives <= 0) triggerGameOver(false); }
            timerSpan.innerText = timeLeft.toFixed(1); updateTimeBar();

            orange.x += orange.vx; orange.y += orange.vy;
            if (orange.x < orange.r) { orange.x = orange.r; orange.vx *= -0.8; }
            if (orange.x > canvas.width - orange.r) { orange.x = canvas.width - orange.r; orange.vx *= -0.8; }
            if (orange.y < orange.r) { orange.y = orange.r; orange.vy *= -0.8; }
            if (orange.y > canvas.height - orange.r) { orange.y = canvas.height - orange.r; orange.vy *= -0.8; }

            if (redBall.active) {
                redBall.x += redBall.vx; redBall.y += redBall.vy;
                if (redBall.x < redBall.r) { redBall.x = redBall.r; redBall.vx *= -0.8; }
                if (redBall.x > canvas.width - redBall.r) { redBall.x = canvas.width - redBall.r; redBall.vx *= -0.8; }
                if (redBall.y < redBall.r) { redBall.y = redBall.r; redBall.vy *= -0.8; }
                if (redBall.y > canvas.height - redBall.r) { redBall.y = canvas.height - redBall.r; redBall.vy *= -0.8; }
            }

            if (fingerPos.valid) {
                const dx = fingerPos.x - orange.x, dy = fingerPos.y - orange.y;
                if (Math.sqrt(dx*dx + dy*dy) < orange.r + 18) {
                    score++; scoreSpan.innerText = score;
                    timeLeft = Math.min(timeLeft + TIME_PER_POP, 45);
                    timerSpan.innerText = timeLeft.toFixed(1); updateTimeBar();
                    playPopSound(); spawnOrange();
                }
                if (redBall.active) {
                    const dxR = fingerPos.x - redBall.x, dyR = fingerPos.y - redBall.y;
                    if (Math.sqrt(dxR*dxR + dyR*dyR) < redBall.r + 18) {
                        loseLife(); spawnRed();
                    }
                }
            }
        }
        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // UI buttons
    toggleBtn.addEventListener('click', () => {
        initAudioOnUserGesture();
        if (gameActive && !gameOverFlag) manualGameStop();
        else { if (gameOverFlag) restartGame(); else manualGameStart(); }
    });

    musicBtn.addEventListener('click', () => { initAudioOnUserGesture(); setMusicEnabled(!musicEnabled); });
    restartBtn.addEventListener('click', () => { initAudioOnUserGesture(); restartGame(); });

    setMusicEnabled(true);
    spawnOrange(); spawnRed();
})();
</script>
</body>
</html>
