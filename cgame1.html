<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> FIST FIX ¬∑ start/stop ¬∑ red risk</title>
    <!-- MediaPipe hands (light) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: #0a0d14;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            padding: 6px;
        }
        .game-container {
            position: relative;
            width: 92vw;
            height: 96vh;
            border-radius: 32px;
            overflow: hidden;
            box-shadow: 0 20px 45px rgba(0,0,0,0.9);
            border: 2px solid #ffaa3366;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #141a26;
            cursor: none;
        }
        /* dashboard */
        #dashboard {
            position: absolute;
            top: 16px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            z-index: 20;
            flex-wrap: wrap;
            padding: 0 10px;
        }
        .panel {
            background: rgba(8, 12, 24, 0.8);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 180, 70, 0.4);
            border-radius: 40px;
            padding: 8px 20px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-weight: 600;
            font-size: 1.4rem;
        }
        .panel span {
            color: #ffb347;
            font-weight: 800;
            margin-left: 4px;
            min-width: 40px;
            text-align: center;
        }
        .time-bar-bg {
            width: 90px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            overflow: hidden;
            margin-left: 5px;
            border: 1px solid rgba(255,200,100,0.3);
        }
        .time-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #6ef0a0, #ffcd7e);
            border-radius: 20px;
            transition: width 0.1s linear;
        }

        /* start/stop toggle (corner) - now acts as START/STOP, not pause */
        #toggleGameBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #1e2a3a;
            border: 2px solid #ffb347;
            color: white;
            font-size: 1.7rem;
            font-weight: bold;
            padding: 12px 22px;
            border-radius: 60px;
            cursor: pointer;
            z-index: 50;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 20px black;
            transition: 0.2s;
            line-height: 1;
            pointer-events: auto;
        }
        #toggleGameBtn.active {
            background: #2f6b3e;
            border-color: #a0ff9e;
            color: #e8ffe8;
        }

        /* pause indicator (no hand) */
        .pause-indicator {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(200, 50, 50, 0.95);
            color: white;
            padding: 6px 22px;
            border-radius: 40px;
            font-size: 1.3rem;
            font-weight: bold;
            backdrop-filter: blur(4px);
            border: 1px solid #ff8a8a;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            white-space: nowrap;
        }

        /* temporary hint */
        .gesture-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
            color: #eee;
            padding: 10px 22px;
            border-radius: 40px;
            font-size: 1rem;
            border: 1px solid #ffaa3380;
            z-index: 30;
            pointer-events: none;
            font-weight: 500;
            transition: opacity 0.8s;
        }
        .gesture-hint.fade {
            opacity: 0;
        }

        /* game over overlay */
        #gameover {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            visibility: hidden;
            border-radius: 32px;
        }
        .gameover-card {
            background: #1a1f2e;
            padding: 40px 50px;
            border-radius: 50px;
            border: 2px solid #ffaa33;
            text-align: center;
            box-shadow: 0 20px 40px black;
        }
        .gameover-card h1 {
            font-size: 3rem;
            color: #ffc164;
            margin-bottom: 15px;
        }
        .gameover-card p {
            font-size: 2rem;
            color: white;
        }
        #restartBtn {
            background: #ffaa33;
            border: none;
            font-size: 1.8rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            color: #0b0e14;
            cursor: pointer;
            margin-top: 25px;
            transition: 0.2s;
        }
        #restartBtn:hover {
            background: #ffbf5e;
            transform: scale(1.03);
        }
        video { display: none; }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="canvas"></canvas>

    <!-- START/STOP button (pure start/stop) -->
    <div id="toggleGameBtn" class="active">‚èπÔ∏è STOP</div>

    <!-- Dashboard -->
    <div id="dashboard">
        <div class="panel">
            ‚è≥<span id="timerDisplay">30</span>s
            <div class="time-bar-bg"><div id="timeFill" class="time-fill" style="width:100%"></div></div>
        </div>
        <div class="panel">
            ‚ù§Ô∏è <span id="livesDisplay">3</span>
        </div>
        <div class="panel">
            üçä<span id="scoreDisplay">0</span>
        </div>
    </div>

    <!-- Pause indicator (hand lost) -->
    <div id="pauseIndicator" class="pause-indicator">‚è∏Ô∏è NO HAND ¬∑ waiting</div>

    <!-- Bottom hint (fades) -->
    <div class="gesture-hint" id="gestureHint">
        ‚úåÔ∏è peace = restart (when over) &nbsp; ‚úä CLOSE FIST = STOP now
    </div>

    <!-- Game over overlay -->
    <div id="gameover">
        <div class="gameover-card">
            <h1>GAME OVER</h1>
            <p>üçä <span id="finalScore">0</span></p>
            <p>‚úåÔ∏è show peace sign to restart</p>
            <button id="restartBtn">‚Üª PLAY AGAIN</button>
        </div>
    </div>

    <video id="video" autoplay playsinline></video>
</div>

<script>
(function() {
    // ----- DOM -----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');

    const timerSpan = document.getElementById('timerDisplay');
    const livesSpan = document.getElementById('livesDisplay');
    const scoreSpan = document.getElementById('scoreDisplay');
    const finalScoreSpan = document.getElementById('finalScore');
    const timeFill = document.getElementById('timeFill');
    const gameoverDiv = document.getElementById('gameover');
    const restartBtn = document.getElementById('restartBtn');
    const pauseIndicator = document.getElementById('pauseIndicator');
    const toggleBtn = document.getElementById('toggleGameBtn');
    const hintEl = document.getElementById('gestureHint');

    // fade out hint after 4 sec
    setTimeout(() => {
        hintEl.classList.add('fade');
    }, 4000);

    // ----- constants -----
    const INIT_TIME = 30;
    const INIT_LIVES = 3;
    const TIME_PER_POP = 2;
    const ORANGE_RADIUS = 30;
    const RED_RADIUS = 28;

    // ----- game state -----
    let score = 0;
    let lives = INIT_LIVES;
    let timeLeft = INIT_TIME;
    // gameActive: true = running, false = fully stopped (game over or manual stop)
    let gameActive = true;         
    let gameOverFlag = false;       // separate flag to distinguish manual stop vs game over
    let manualStop = false;         // track if STOP button was pressed

    // Hand tracking
    let handDetected = false;
    let fingerPos = { x: -100, y: -100, valid: false };
    let smoothedX = -100, smoothedY = -100;

    // Gesture cooldown
    let lastPeaceTime = 0;
    let lastFistStopTime = 0;
    const GESTURE_COOLDOWN = 900; // ms

    // ----- balls -----
    let orange = {
        x: 300, y: 200, r: ORANGE_RADIUS,
        vx: 0.2, vy: 0.15,
    };
    let redBall = {
        active: true,
        x: 150, y: 400, r: RED_RADIUS,
        vx: -0.3, vy: 0.25,
    };

    // resize canvas
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        [orange, redBall].forEach(b => {
            const margin = b.r + 20;
            if (b.x < margin) b.x = margin;
            if (b.x > canvas.width - margin) b.x = canvas.width - margin;
            if (b.y < margin) b.y = margin;
            if (b.y > canvas.height - margin) b.y = canvas.height - margin;
        });
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function spawnOrange() {
        const margin = orange.r + 25;
        orange.x = Math.random() * (canvas.width - 2 * margin) + margin;
        orange.y = Math.random() * (canvas.height - 2 * margin) + margin;
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.18 + Math.random() * 0.3;
        orange.vx = Math.cos(angle) * speed;
        orange.vy = Math.sin(angle) * speed;
    }

    function spawnRed() {
        const margin = redBall.r + 25;
        redBall.x = Math.random() * (canvas.width - 2 * margin) + margin;
        redBall.y = Math.random() * (canvas.height - 2 * margin) + margin;
        const angle = Math.random() * 2 * Math.PI;
        const speed = 0.24 + Math.random() * 0.3;
        redBall.vx = Math.cos(angle) * speed;
        redBall.vy = Math.sin(angle) * speed;
        redBall.active = true;
    }

    // restart full game (also called by peace sign)
    function restartGame() {
        gameActive = true;
        gameOverFlag = false;
        manualStop = false;
        toggleBtn.innerText = '‚èπÔ∏è STOP';
        toggleBtn.classList.add('active');
        gameoverDiv.style.visibility = 'hidden';
        score = 0;
        lives = INIT_LIVES;
        timeLeft = INIT_TIME;
        scoreSpan.innerText = score;
        livesSpan.innerText = lives;
        timerSpan.innerText = timeLeft;
        updateTimeBar();
        spawnOrange();
        spawnRed();
        handDetected = false;
        fingerPos.valid = false;
        pauseIndicator.style.opacity = '0';
        smoothedX = smoothedY = -100;
    }

    // game over (by red or fist or lives)
    function triggerGameOver(byFist = false) {
        if (gameOverFlag) return;          // already game over
        gameActive = false;
        gameOverFlag = true;
        manualStop = false;                // it's a real game over
        toggleBtn.innerText = '‚ñ∂Ô∏è START';
        toggleBtn.classList.remove('active');
        finalScoreSpan.innerText = score;
        gameoverDiv.style.visibility = 'visible';
        pauseIndicator.style.opacity = '0';
    }

    // manual STOP (button) ‚Äì stops game without game over overlay
    function manualGameStop() {
        if (!gameActive) return;            // already stopped
        gameActive = false;
        manualStop = true;
        gameOverFlag = false;               // not game over, just manual stop
        toggleBtn.innerText = '‚ñ∂Ô∏è START';
        toggleBtn.classList.remove('active');
        gameoverDiv.style.visibility = 'hidden';   // no overlay
        pauseIndicator.style.opacity = handDetected ? '0' : '1'; 
    }

    // manual START (button)
    function manualGameStart() {
        if (gameOverFlag) {
            // if game over, restart fully
            restartGame();
        } else {
            // just resume from manual stop
            gameActive = true;
            manualStop = false;
            toggleBtn.innerText = '‚èπÔ∏è STOP';
            toggleBtn.classList.add('active');
            pauseIndicator.style.opacity = '0';
        }
    }

    // lose life (red ball hit)
    function loseLife() {
        if (!gameActive || gameOverFlag) return;
        lives--;
        livesSpan.innerText = lives;
        if (lives <= 0) {
            triggerGameOver(false);
        } else {
            spawnRed();
            // red flash
            ctx.save();
            ctx.fillStyle = 'rgba(255,80,80,0.3)';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.restore();
        }
    }

    function updateTimeBar() {
        let percent = Math.max(0, (timeLeft / INIT_TIME) * 100);
        timeFill.style.width = percent + '%';
    }

    // ---------- GESTURES (strict) ----------
    function isPeaceSign(landmarks) {
        const indexTip = landmarks[8];
        const indexDip = landmarks[6];
        const indexUp = indexTip.y < indexDip.y - 0.018;
        const middleTip = landmarks[12];
        const middleDip = landmarks[10];
        const middleUp = middleTip.y < middleDip.y - 0.018;
        const ringTip = landmarks[16];
        const ringDip = landmarks[14];
        const ringDown = ringTip.y > ringDip.y + 0.015;
        const pinkyTip = landmarks[20];
        const pinkyDip = landmarks[18];
        const pinkyDown = pinkyTip.y > pinkyDip.y + 0.015;
        const thumbTip = landmarks[4];
        const thumbIp = landmarks[3];
        const thumbDown = thumbTip.y > thumbIp.y - 0.02;
        return indexUp && middleUp && ringDown && pinkyDown && thumbDown;
    }

    // CLOSE FIST ‚Äì all fingers clearly curled
    function isCloseFist(landmarks) {
        const indexTip = landmarks[8];
        const indexDip = landmarks[6];
        const indexDown = indexTip.y > indexDip.y + 0.025;
        const middleTip = landmarks[12];
        const middleDip = landmarks[10];
        const middleDown = middleTip.y > middleDip.y + 0.025;
        const ringTip = landmarks[16];
        const ringDip = landmarks[14];
        const ringDown = ringTip.y > ringDip.y + 0.025;
        const pinkyTip = landmarks[20];
        const pinkyDip = landmarks[18];
        const pinkyDown = pinkyTip.y > pinkyDip.y + 0.025;
        const thumbTip = landmarks[4];
        const thumbIp = landmarks[3];
        const thumbDown = thumbTip.y > thumbIp.y - 0.01; 
        return indexDown && middleDown && ringDown && pinkyDown && thumbDown;
    }

    // ----- MediaPipe setup -----
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,
        minDetectionConfidence: 0.65,
        minTrackingConfidence: 0.65,
        selfieMode: true
    });

    hands.onResults((results) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // draw camera
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#141a26';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // HAND block
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            const landmarks = results.multiHandLandmarks[0];
            const now = Date.now();

            // --- PEACE (restart only when game over) ---
            if (gameOverFlag && (now - lastPeaceTime > GESTURE_COOLDOWN)) {
                if (isPeaceSign(landmarks)) {
                    lastPeaceTime = now;
                    restartGame();
                }
            }

            // --- CLOSE FIST = immediate STOP (always if game active, regardless of toggle) ---
            if (gameActive && !gameOverFlag && (now - lastFistStopTime > GESTURE_COOLDOWN)) {
                if (isCloseFist(landmarks)) {
                    lastFistStopTime = now;
                    triggerGameOver(true);   // fist triggers game over
                }
            }

            // fingertip smoothing
            const indexTip = landmarks[8];
            let rawX = indexTip.x * canvas.width;
            let rawY = indexTip.y * canvas.height;
            if (smoothedX < 0) {
                smoothedX = rawX;
                smoothedY = rawY;
            } else {
                const alpha = 0.35;
                smoothedX = smoothedX * alpha + rawX * (1 - alpha);
                smoothedY = smoothedY * alpha + rawY * (1 - alpha);
            }
            fingerPos.x = smoothedX;
            fingerPos.y = smoothedY;
            fingerPos.valid = true;

            // draw fingertip
            ctx.beginPath();
            ctx.arc(fingerPos.x, fingerPos.y, 18, 0, 2*Math.PI);
            ctx.fillStyle = '#55ffb0';
            ctx.shadowColor = '#00cc88';
            ctx.shadowBlur = 25;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(fingerPos.x, fingerPos.y, 6, 0, 2*Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        } else {
            handDetected = false;
            fingerPos.valid = false;
            smoothedX = smoothedY = -100;
        }

        // draw orange
        ctx.shadowColor = '#ffaa33';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(orange.x, orange.y, orange.r, 0, 2*Math.PI);
        ctx.fillStyle = '#ff8c00';
        ctx.fill();
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(orange.x-5, orange.y-5, orange.r-8, 0, 2*Math.PI);
        ctx.fillStyle = '#ffb86b';
        ctx.fill();
        ctx.shadowBlur = 0;

        // draw red ball
        if (redBall.active) {
            ctx.shadowColor = '#ff3a3a';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(redBall.x, redBall.y, redBall.r, 0, 2*Math.PI);
            ctx.fillStyle = '#d83030';
            ctx.fill();
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(redBall.x-5, redBall.y-5, redBall.r-8, 0, 2*Math.PI);
            ctx.fillStyle = '#ff7777';
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    // Camera
    const camera = new Camera(video, {
        onFrame: async () => {
            await hands.send({ image: video });
        },
        width: 800,
        height: 600,
        facingMode: 'user'
    });
    camera.start().catch(e => console.warn);

    // ----- game loop (physics) -----
    let lastTimestamp = 0;

    function gameLoop(now) {
        if (!lastTimestamp) {
            lastTimestamp = now;
            requestAnimationFrame(gameLoop);
            return;
        }
        const delta = now - lastTimestamp;
        lastTimestamp = now;

        // update UI pause indicator
        if (!handDetected && gameActive && !gameOverFlag && !manualStop) {
            pauseIndicator.style.opacity = '1';
        } else {
            pauseIndicator.style.opacity = '0';
        }

        if (gameActive && !gameOverFlag) {
            // timer countdown only if hand visible
            if (handDetected) {
                timeLeft -= delta / 1000;
            }

            // time out -> lose life
            if (timeLeft <= 0) {
                timeLeft = INIT_TIME * 0.8;
                lives--;
                livesSpan.innerText = lives;
                if (lives <= 0) { triggerGameOver(false); }
            }

            timerSpan.innerText = timeLeft.toFixed(1);
            updateTimeBar();

            // move orange
            orange.x += orange.vx;
            orange.y += orange.vy;
            if (orange.x < orange.r) { orange.x = orange.r; orange.vx *= -0.8; }
            if (orange.x > canvas.width - orange.r) { orange.x = canvas.width - orange.r; orange.vx *= -0.8; }
            if (orange.y < orange.r) { orange.y = orange.r; orange.vy *= -0.8; }
            if (orange.y > canvas.height - orange.r) { orange.y = canvas.height - orange.r; orange.vy *= -0.8; }

            // move red
            if (redBall.active) {
                redBall.x += redBall.vx;
                redBall.y += redBall.vy;
                if (redBall.x < redBall.r) { redBall.x = redBall.r; redBall.vx *= -0.8; }
                if (redBall.x > canvas.width - redBall.r) { redBall.x = canvas.width - redBall.r; redBall.vx *= -0.8; }
                if (redBall.y < redBall.r) { redBall.y = redBall.r; redBall.vy *= -0.8; }
                if (redBall.y > canvas.height - redBall.r) { redBall.y = canvas.height - redBall.r; redBall.vy *= -0.8; }
            }

            // collisions
            if (fingerPos.valid) {
                // orange pop
                const dx = fingerPos.x - orange.x;
                const dy = fingerPos.y - orange.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < orange.r + 18) {
                    score++;
                    scoreSpan.innerText = score;
                    timeLeft = Math.min(timeLeft + TIME_PER_POP, 45);
                    timerSpan.innerText = timeLeft.toFixed(1);
                    updateTimeBar();
                    spawnOrange();
                }

                // red danger
                if (redBall.active) {
                    const dxR = fingerPos.x - redBall.x;
                    const dyR = fingerPos.y - redBall.y;
                    const distR = Math.sqrt(dxR*dxR + dyR*dyR);
                    if (distR < redBall.r + 18) {
                        loseLife();
                        spawnRed();
                    }
                }
            }
        }

        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // ----- toggle button: START/STOP (pure) -----
    toggleBtn.addEventListener('click', () => {
        if (gameActive && !gameOverFlag) {
            // if running -> STOP (manual stop, no game over)
            manualGameStop();
        } else {
            // if stopped (manual stop or game over) -> START
            if (gameOverFlag) {
                restartGame();          // full restart
            } else {
                manualGameStart();       // resume from manual stop
            }
        }
    });

    restartBtn.addEventListener('click', restartGame);

    // init
    spawnOrange();
    spawnRed();
})();
</script>
</body>
</html>
